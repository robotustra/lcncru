Глава 1
Введение
Это руководство находится в процессе разработки. Если вы можете помочь в написании, редактировании или подготовке графики, 
пожалуйста, свяжитесь с любым членом команды редакторов или хотите присоединиттся к ней, то отправьте электронное письмо на адрес emc-users@lists.sourceforge.net.
Copyright © 2000-2015 LinuxCNC.org
Разрешается копировать, распространять и / или изменять этот документ в соответствии с условиями лицензии GNU Free Documentation License,
Версия 1.1 или любая более поздняя версия, опубликованная Free Software Foundation; Без инвариантных разделов, без текстов с передней обложкой,
И без обратных обложек. Копия лицензии включена в раздел «Лицензия на бесплатную документацию GNU».
LINUX® является зарегистрированным товарным знаком Линуса Торвальдса в США и других странах. Зарегистрированный товарный знак Linux® используется
В соответствии с сублицензией от LMI, эксклюзивным лицензиатом Линуса Торвальдса, владельца знака на всемирной основе.
Проект LinuxCNC не связан с Debian®. Debian является зарегистрированным товарным знаком, принадлежащим Программному обеспечению в интересах общества,
Inc.
Проект LinuxCNC не связан с UBUNTU®. UBUNTU является зарегистрированным товарным знаком, принадлежащим Canonical Limited.


Глава 2
История LinuxCNC
2.1 Происхождение
EMC (Enhanced Machine Controller) был создан NIST, Национальным институтом стандартов и технологий, который является агентством Министерства торговли США.

NIST сначала заинтересовался в написании пакета управления движением в качестве тестовой платформы для концепций и стандартов. Раннее спонсорство от General Motors привело к адаптации новой версии EMC с использованием интеллектуальных панелей управления PMAC под версией Windows NT в реальном времени и управлением крупным фрезерным станком.

Как требуется для всех рабочих продуктов федерального правительства США, конечное программное обеспечение и отчет о нем должен быть общедоступным и должным образом опубликованым, в том числе в Интернете. Именно там Мэт Шэйвер (Matt Shaver) обнаружил EMC. Он связался с NIST и вступил в переговоры с Фредом Проктором (Fred Proctor) об адаптации кода для использования его в управлении менее дорогостоящим оборудованием, которое будет использоваться для обновлений и замены элементов управления ЧПУ, которые были устаревшими или в нерабочем состоянии.

NIST был заинтригован, потому что они также хотели что-то дешевле. Для начала совместных действий, было создано соглашение, гарантирующее, что полученный код и дизайн останутся в общественном достоянии.

Ранние усилия были сосредоточены на замене дорогостоящей системы Windows NT в реальном времени. 
Было предложено использовать относительно новые (в то время) расширения реального времени операционной системы Linux. Эта идея оказалась успешной. 
Следующим шагом было решение проблемы дорогостоящих интеллектуальных систем управления движением. К этому времени вычислительная мощность ПК была уже
достаточно велика, чтобы напрямую контролировать управление движением.

Быстрый поиск доступных аппаратных средств привел к выбору интерфейсная плата Servo-To-Go в качестве первой платформы, позволяющей ПК напрямую управлять двигателями. Программное обеспечение для планирования траектории и управление ПИД-регулятором было добавлено к существующему пользовательскому интерфейсу и интерпретатору RS274. Мэтт успешно использовал эту версию для модернизации нескольких машин с ручными элементами управления, и это стало системой EMC, которая впервые привлекла внимание общественности. Упоминание EMC о Rec.Crafts.Metalworking дискуссионной группе USENET привело к ранним последователям, таким как Джон Эльсон (Jon Elson), который использовал преимущества EMC.

NIST создал список рассылки для людей, заинтересованных в EMC. Со временем другие люди вне NIST заинтересовались улучшением
EMC. Много людей запрашивали или кодировали небольшие улучшения в коде. Рэй Генри (Ray Henry) хотел улучшить пользовательский интерфейс. 
Поскольку Рэй не хотел модифицировать код на Си, на котором был написан пользовательский интерфейс, был предложен более простой метод. Фред
Проктор из NIST предложил скриптовый язык и написал код для взаимодействия с языком Tcl/Tk с внутренним языком NML для коммуникаций в EMC. 
С помощью этого инструмента Рэй продолжил писать программу на Tcl/Tk, который в основном используется в пользовательском интерфейсе в EMC на сегодняшний момент.

С течением времени интерес к EMC как-то начинает заметно расти. По мере того как все большее число людей пытались установить EMC, стали очевидны 
сложности в установке патчей ядра Linux для расширения реального времени и компиляции кода EMC. Было предпринято множество попыток документировать процесс и писать сценарии, которые делались с переменным успехом. 
Продолжали возникать проблемы соответствия правильной версии патчей и компиляторов с выбранной версией Linux. Пол Корнер (Paul Corner)
пришел на помощь с BDI (brain dead install), записанной на компакт-диске, с которого можно было загрузить полную рабочую систему (Linux, патчи,
и EMC). BDI от Пола превратился в загрузочный компакт-диск, который можно было запускать на большинстве ПК для тестирования EMC, не перезаписывая существующую систему на жестком диске. Как только пользователь решит, что им нужна постоянная система EMC, то с того же CD можно установить полную среду EMC/Linux. 
Подход BDI открыл мир EMC для гораздо больше потенциального сообщества пользователей. По мере того как это сообщество становилось больше, список рассылки EMC и кодовые архивы были перемещены на SourceForge и на веб-сайте LinuxCNC.

При участии большего сообщества пользователей EMC стала основным объектом интереса на текущих выставках CNC в NAMES и NAMES стали ежегодным мероприятием для EMC. В течение первых двух лет встречи происходили потому, что заинтересованные стороны участвовали в NAMES. В 2003 году сообщество пользователей EMC провело свое первое публичное собрание, которое произошло в понедельник в фойе арены, где проводилась выставка NAMES. Организация была свободной, и была предложена идея создания слоя аппаратной абстракции (HAL), а такде возникло движение по реструктуризации кода для облегчения разработки (EMC2).


2.2 Изменение имени
Весной 2011 года с советом директоров LinuxCNC связалась юридическая фирма, представляющая корпорацию EMC (www.emc.com) об использовании «EMC» и «EMC2» для идентификации программного обеспечения, предлагаемого на linuxcnc.org. Корпорация EMC зарегистрировала различные товарные знаки, относящиеся к EMC и EMC2
(EMC с надстрочной цифрой 2).
Результатом ряда бесед с представителем корпорации EMC привел к тому, что, начиная со следующего крупного релиза программного обеспечения, linuxcnc.org прекратит идентификацию программного обеспечения с помощью «emc» или «EMC» или тех терминов, которые будут сопровождаться цифрами.

В той степени, в которой Совет директоров LinuxCNC контролирует имена, используемые для идентификации программного обеспечения, предлагаемого на linuxcnc.org, совет согласился с этим.

Необходимо было выбрать новое имя для программного обеспечения. Из вариантов, рассмотренных советом, был достигнут консенсус, что «LinuxCNC» - лучший вариант, так как это имя нашего сайта уже много лет.

При подготовке перехода к новому имени мы получили сублицензию товарного знака LINUX® от Linux Foundation (www.linuxfoundation.org), защищая наше использование имени LinuxCNC. (LINUX® является зарегистрированным товарным знаком Линуса Торвальдса в США и других странах).
К ребрендингу прилагаются веб-сайт linuxcnc.org, каналы IRC и версии программного обеспечения и документации
Начиная с 2.5.0.

2.3 Дополнительная информация
NIST опубликовал статью, описывающую язык RS274NGC и абстракцию машинного центра, которым он управляет, так же как и в ранних реализациях EMC. 
Эта работа доступна по адресу http://linuxcnc.org/files/RS274NGCv3.pdf
NIST также опубликовал статью об истоии EMC и его передаче в откытое пользование (open source). Эта статья доступна по адресу http://linuxcnc.org/-
files/Use-of-Open-Source-Distribution-for-a-Machine-Tool-Controller.pdf


Глава 3
Главная информация
3.1 Предисловие пользователя
LinuxCNC является модульным и гибким. Это заставляет многих думать, что это приводит к беспорядоку и путанице и удивляться, почему это так. 
Эта страница пытается ответить на вопрос о модульности, прежде чем разбираться детальнее.

LinuxCNC начал работу в Национальном институте стандартов и технологий в США. Он вырос с использованием Unix в качестве операционной
системы. Среди ранних разработчиков Unix появился ряд идей для написания кода, которые некоторые называют способом Unix (Unix way).
Первые авторы LinuxCNC следовали этим путем.

Эрик С. Раймонд (Eric S. Raymond) в своей книге «Искусство программирования Unix» обобщает философию Unix как широко используемую философию в технике: «Делай все просто, для дураков» (принцип KISS, "Keep it Simple, Stupid"). Затем он описывает, как он считает, что эта общая философия используется как культурная норма Unix, хотя неудивительно, что легко найти серьезные нарушения из следующих положений в фактической практике Unix:
• Правило модульности: Пишите простые части, соединенные ясными интерфейсами.
• Правило ясности: Ясность лучше, чем умение.
• Правило композиции: Проектируйте программы так, чтобы их легко было подключать к другим программам.
• Правило разделения: Отделяйте политику от механизма; Отделяйте интерфейсы от процессоров (engines).

Г-н Раймонд предложил еще несколько правил, но эти четыре описывают основные характеристики системы управления движением LinuxCNC.
Правило модульности имеет решающее значение. Во всех этих руководствах вы найдете информацию о интерпретаторе или планировщике задач или движении или HAL. Каждый из них представляет собой модуль или набор модулей. Это модульность позволяет вам соединять только те части, которые вам необходимы чтобы запустить вашу машину.

Правило Ясности имеет важное значение. LinuxCNC - находится в стадии разработки, которая не завершена и никогда не будет завершена. Она достаточно завершена, чтобы запускаться на большинство машин. Большая часть этого прогресса достигнута благодаря тому, что многие пользователи и разработчики кода могут видеть и понимать работу других и основываться на том, что они сделали.

Правило Композиции позволяет нам создавать предсказуемую систему управления из множества доступных модулей, делая их доступными для подключения. Мы достигаем возможности подключения, устанавливая стандартные интерфейсы для наборов модулей и следуя этим стандартам.

В правиле разделения требуется, чтобы мы делали разные части, которые могут не очень много в одном модуле. 
Разделяя модули отладка становится намного проще и заменяющие модули могут быть добавлены в систему и легко сравниваться с другими модулями.


Что означает путь Unix для вас как пользователя LinuxCNC? Прежде всего вы можете сделать свой выбор модулей согласно тому, как вы будете использовать систему. Многие из вариантов являются частью интеграции с машиной, но многие варианты зависят от того, как вы собираетесь использовать вашу машину (станок, систему).

По мере прочтения вы найдете много мест, где вам нужно будет рассматривать разные варианты модулей. В конце концов вы сделаете выбор: «Я буду использовать этот интерфейс, а не тот» или «Я напишу часть позиционирования таким образом, а не таким образом». Во всех этих руководствах мы описываем весь диапазон доступных возможностей.

Когда вы начинаете свое путешествие в LinuxCNC, мы хотим сделать два предостережения:
• Перефразируя слова Дуга Гвина (Doug Gwin) в UNIX: «LinuxCNC не был предназначен для того чтобы не позволять его пользователям делать глупые вещи, так как это также помешало бы им делать умные вещи».

• Точно так же слова Стивена Кинга (Steven King): «LinuxCNC удобен для пользователя. Он просто не разбирается в том, с какими пользователями он дружит».




3.2 Введение пользователя LinuxCNC
------------------------
3.2.1 Как работает LinuxCNC

Когда вы запускаете LinuxCNC из меню ЧПУ или набрав linuxcnc в терминале, скрипт LinuxCNC запускает выбор конфигурации системы (Configuration Selector). Когда вы выбираете конфигурацию, LinuxCNC считывает INI-файл, затем загружает файлы HAL в том порядке, в котором они перечислены в INI-файле.

Когда вы создаете конфигурацию с помощью мастера настройки шаговых двигателей (Stepper Configuration Wizard) или мастера аппаратного обеспечения (Mesa Hardware Wizard) или выбирая образец конфигурации из Селектора конфигураций, LinuxCNC создает некоторые каталоги и файлы в вашем пользовательском каталоге. В следующем примере имя конфигурации - My Lathe (Мой токарный станок).
• linuxcnc
	- configs
	* My_Lathe
		· My_Lathe.ini (это прочитано скриптом linuxcnc)
		· My_Lathe.hal (этот файл hal загружается перед gui)
		· Post_gui.hal (этот файл hal загружается после gui)
		· Linuxcnc.var (сохраняет параметры)
		· Linuxcnc.var.bak (файл параметров резервного копирования)
		· Tool.tbl (файл таблицы инструментов)
- nc_files
* * .ngc (файлы G-кода)

В конфигурации могут быть и другие каталоги и файлы, но, файлы, описанные выще это минимально необходимые для работы файлы.
LinuxCNC может управлять станками, роботами или другими автоматическими устройствами. Он может управлять серводвигателями, шаговыми двигателями, реле и другими устройствами, связанными с управлением движением. LinuxCNC может управлять системами, имеющими до 9 осей (9 DOF)в координированном движении.

Существует пять основных компонентов программного обеспечения LinuxCNC:
• контроллер движения (EMCMOT)
• дискретный контроллер ввода / вывода (EMCIO)
• исполнитель задачи, который их координирует (EMCTASK)
• графический интерфейс пользователя.
• слой абстракции оборудования (HAL)

Рисунок 3.1: Простая система управления LinuxCNC

На приведенном выше рисунке показана простая блок-схема типичной 3-осевой системы в LinuxCNC. Эта диаграмма показывает систему шаговых двигателей. Компьютер, работающий под операционной системой Linux, фактически управляет приводами (drivers) шаговых двигателей
отправляя сигналы через порт принтера (LPT). Эти сигналы (импульсы) заставляют драйвера шаговых двигателей вращать сами шаговые двигатели. Система LinuxCNC может также запускать сервомоторы через сервоусилительные карты или использовать расширенный параллельный порт для подключения к внешним схемам управления. Когда мы рассмотрим каждый из компонентов, составляющих систему LinuxCNC, мы напомним читателю об этой типичной конфигурации системы.

3.2.2 Графический интерфейс пользователя (GUI)
Пользовательский интерфейс является частью LinuxCNC и с ней взаимодействует оператор станка. LinuxCNC поставляется с несколькими типами пользовательских интерфейсов:
Axis, стандартный вид интерфеса клавиатуры.
// picture

Touchy, интерфейс тачскрина GUI.
//picture

gmoccapy, a touch screen GUI based on Gscreen
//picture

NGCGUI, GUI подпрограммы, который обеспечивает выполнение программ на G-коде. Он также поддерживает склеивание файлов подпрограмм, чтобы вы могли создавать полный файл G-кода без программирования. Следующий снимок экрана показывает NGCGUI, встроенный в Axis.

//picture

Keystick - GUI на базе символьной графики и псевдографики, предназначенный для минимальной установки (без запуска X-сервера).

//picture

3.2.2.1 Дополнительные функции
• Xemc, программа X-Windows. Конфигурация симулятора Xemc может быть запущена из конфигуратора.
• halui - пользовательский интерфейс на основе HAL, который позволяет управлять LinuxCNC с помощью ручек и переключателей. Дополнительную информацию см. В главе HALUI. 
• linuxcncrsh - пользовательский интерфейс на основе telnet, который позволяет отправлять команды в LinuxCNC с удаленных компьютеров.

3.2.3 Виртуальные панели управления
• PyVCP - виртуальная панель управления, написанная на python, которая может быть добавлена в графический интерфейс Axis или запускаться автономно.

//picture

Рисунок 3.2: PyVCP с осью
• GladeVCP - виртуальная панель управления на основе полей, которая может быть добавлена в графический интерфейс Axis или быть автономной.

//picture

Рисунок 3.3: GladeVCP с осью
См. Главу PyVCP и главу GladeVCP для получения дополнительной информации о виртуальных панелях управления.

3.2.4 Языки
LinuxCNC использует файлы локализации для перевода пользовательских интерфейсов LinuxCNC на многие языки. Вам просто нужно войти в систему с языком, который вы собираетесь использовать, и когда вы запускаете LinuxCNC, он появляется на этом языке. Если ваш язык не был переведен, свяжитесь с разработчиком в IRC или в списке рассылки, если вы можете помочь в переводе.

3.2.5. Мыслите как оператор ЧПУ станка
Эта книга не является руководством по управлению ЧПУ станками. Для того чтобы стать оператором станков ЧПУ необходимо много времени и много работы. 
Один автор однажды сказал: «Мы учимся на собственном опыте, если вообще учимся». 
Сломанные инструменты, поврежденные тиски и шрамы - свидетельство подобных уроков. Хорошая финишная обработка, малые допусти и хорошая работа - свидетельство выученных уроков. Никакая машина и никакая компьютерная программа, не может заменить человеческий опыт.

Когда вы начинаете работать с программой LinuxCNC, вам необходимо представлять себя на месте оператора ЧПУ станка. Теперь вы отвечаете за машину. Это машина, которая либо ждет вашу команду, либо выполняет команду, которую вы только что дали. На всех этих этапах мы предоставляем информацию, которая поможет вам стать хорошим оператором системы LinuxCNC. Кое-какая информация вам понадобится прямо здесь, чтобы следующие страницы имели для вас смысл.

3.2.6 Режимы работы
Когда LinuxCNC запущен, для ввода команд используются три основных режима. Это ручной режим (Manual), автоматически (Auto) и MDI. Переход из одного режима в другой имеет большое значение в том, как ведет себя управление LinuxCNC. Есть конкретные вещи, которые можно сделать только в одном режиме, и нельзя сделать в другом. Оператор может вернуть ось в начало координат (HOME) в ручном режиме, но не в режиме Авто или MDI. Оператор может запустить на выполение весь файл с G-кодом в автоматическом режиме, но не в ручном или MDI режиме.

В ручном режиме каждая команда вводится отдельно. 
С точки зрения человека, ручная команда может включать охлаждающую жидкость или пробег X со скоростью 25 дюймов в минуту. Это эквивалентно переключению тубмлера или повороту ручного колеса для некоторой оси. 
Эти команды обычно обрабатываются на одном из графических интерфейсов, нажимая кнопку с помощью мыши или удерживая клавишу на клавиатуре. 
В автоматическом режиме аналогичная кнопка или нажатие клавиши может использоваться для загрузки или запуска запуска всей программы G-кода, которая хранится в файле. 
В режиме MDI оператор может ввести блок кода и сообщить машине выполнить его, нажав клавишу <return> или <enter> на клавиатуре. 
Имеются некоторые команды управления движением и приводят к одинаковым изменениям во всех режимах. 
Они включают отмену(abort), аварийную остановку (estop) и отмену перезаписи скорости подачи (feed rate override). 
Такие команды должны быть самоочевидными. 

Пользовательский интерфейс AXIS скрывает некоторые различия между Авто и другими режимами, делая автоматические команды доступными в максимально короткие сроки. Он так же прячет разницу между ручным (Manual) и MDI режимами поскольку некоторые ручные команды подобно Touch Off активно реализуется путем отправки команд MDI. Он делает это, автоматически переключаясь в режим, необходимый для действия, которое запросил пользователь.

3.3 Важные концепции пользователей
----------------------------------

В этой главе рассматриваются важные пользовательские концепции, которые следует понимать перед тем, как попытаться запустить ЧПУ станок 
с помощью g-кода.

3.3.1 Управление траекторией
3.3.1.1 Планирование траектории

Планирование траекторий, в общем, является средством, с помощью которого LinuxCNC следует заданной траектории, определенной 
нашей или чьей-либо программой, пока работает в пределах вашего оборудования. 
Программа G-Code никогда не может быть полностью соблюдена. Например, представьте, что вы указываете в качестве однострочной программы следующий ход:
G1 X1 F10 (G1 - линейный ход, X1 - пункт назначения, F10 - скорость)
На самом деле весь ход не может быть проделан на F10, так как машина должна ускоряться с упора, двигаться в направлении X = 1, а затем замедляться, чтобы остановиться снова. Иногда часть движения выполняется на F10, но для многих ходов, особенно коротких, заданная скорость подачи никогда не достигается вообще. Короткий ход вашего G-кода может привести к замедлению работы вашего компьютера и ускорению для более длинных ходов, если простой CAM детектор (naive CAM detector) не используется с командой G64 Pn. 

Простое ускорение и замедление, описанные выше, не являются сложными вне всяких сомнений. В INI-файле определенная машина накладывает ограничения на максимум скорости и ускорения которое будет использоватся планировщиком траектории. 
Для дополнительной информации о параметрах планировщика траектории в ini файле см. Раздел «Траектория» в главе INI.

3.3.1.2 Следование траектории

Менее очевидная проблема заключается в следовании траектории. Когда вы программируете поворот на некоторый угол в G-коде, планировщик траекторий может выполнять несколько действий, все из которых в некоторых случаях являются правильными: он может замедляться до упора точно в координатах угла, а затем ускоряться в новом направлении. 
Он также может выполнять так называемое смешивание, которое должно поддерживать скорость подачи при прохождении через угол, что делает необходимым округлить угол, чтобы подчиняться ограничениям машины. 
Вы можете видеть, что здесь есть компромисс: вы можете замедлить работу, чтобы получить лучший путь, или сохранить скорость и иметь худший путь. В зависимости от конкретного прохода, материала, инструмента и т. Д. Программист может захотеть пойти на компромисс по-разному.
Быстрые движения также подчиняются текущему управлению траекторией. При достаточно длинных ходах, чтобы достичь максимальной скорости на машине с низким ускорением и отсутствием допустимого пути, вы можете получить довольно круглый угол.

3.3.1.3 Программирование планировщика

Команды управления траекторией:

• G61- (режим точного пути, Exact Path Mode) быстро просматривает запрограммированную точку, в то время как это может привести к полной остановке, чтобы изменить направление на следующую запрограммированную точку. 

• G61.1 - (режим точного останова, Exact Stop Mode) сообщает планировщику, что он точно остановится в конце каждого сегмента. 

• G64- (Смешивание без точности, Blend Without Tolerance Mode) G64 является опцией по умолчанию при старте LinuxCNC. 
G64 просто смешивает траектории и простой CAM детектор не включен. G64 и G64 P0 сообщают планировщику пренебрегать точностью пути, 
чтобы поддерживать скорость подачи. 
Это необходимо для некоторых типов материалов или инструментов, где точные остановки являются вредными, и могут отлично работать, пока программист не забывает, что путь инструмента будет несколько более сложным, чем задано в программе.
При использовании G0 (быстрых) ходов с G64 следует соблюдать осторожность при перемещении зазоров и обеспечивать достаточное расстояние 
до препятствий на основе возможностей ускорения вашей машины. 

• G64 P- Q- - (Точное смешивание траекторий, Blend With Tolerance Mode). Это позволяет использовать простой CAM детектор и позволяет смешивать с допуском. 
Если вы программируете G64 P0.05, вы сообщаете планировщику, что вы хотите непрерывную подачу, но в запрограммированных углах вы хотите, чтобы он замедлялся настолько, чтобы траектория инструмента могла оставаться в пределах 0,05 пользовательских единиц запрограммированного пути. 
Точный объем замедления зависит от геометрии запрограммированного угла и ограничений машины, но единственное, о чем программист должен беспокоиться, - это допуск. 
Это дает программисту полный контроль над траекториями после компрометации. 
Допуск смешивания траекторий может быть изменен по всей программе по мере необходимости. 
Помните, что спецификация G64 P0 имеет тот же эффект, что и G64 (выше), что необходимо для обратной совместимости для старых программ G-кода. См. Раздел G64 главы G-кода. 

• Смешивание без допуска. Контролируемая точка будет касаться каждого заданного движения, по крайней мере, в одной точке. Машина никогда не будет двигаться с такой скоростью, чтобы она не могла точно остановиться в конце текущего движения (или следующего движения, если вы приостановите, когда смешение уже началось). Расстояние от конечной точки перемещения велико настолько, насколько нужно, чтобы поддерживать лучший контур подачи. 

• Простой CAM Детектор - последовательные перемещения G1, которые включают в себя только оси XYZ, которые отклоняются меньше, чем Q- от прямой линии, объединяются в одну прямую линию. 
Это объединенное движение заменяет отдельные движения G1 для целей смешивания с допуском. 
Между последовательными движениями контролируемая точка будет проходить не более, чем P- от фактических конечных точек движений.
Контролируемая точка будет касаться хотя бы одной точки на каждом движении. 
Машина никогда не будет двигаться с такой скоростью, чтобы она не могла точно остановиться в конце текущего движения (или следующего движения, если вы приостановите, когда смешение уже началось). 


Движения G2 / 3 в плоскости G17 (XY) когда максимальное отклонение дуги от прямой меньше, чем G64 Q-допуск по сравнению с дугой, то дуга
разбивается на отрезки прямых линий согласно простому CAM алгоритму. Таким образом, линейно-дуговые, дугодуговые, прямые линии являются хорошо обрабатываются простым CAM детектором. Это улучшает производительность обработки контура, упрощая траекторию.



